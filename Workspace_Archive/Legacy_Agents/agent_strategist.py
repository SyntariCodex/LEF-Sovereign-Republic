import os
import json
import re
import random
import time
from pathlib import Path
from datetime import datetime

class AgentStrategist:
    """
    The AgentStrategist is responsible for analyzing the global task list (task.md)
    and generating formal Governance Proposals for pending work items, initiating 
    strategic development cycles.
    """
    
    AGENT_NAME = "Strategist_V1"
    # Assuming standard project structure where brain/ and governance/ are relative to the execution root
    TASK_FILE = Path("brain/task.md")
    PROPOSAL_DIR = Path("governance/proposals")
    CYCLE_INTERVAL_SECONDS = 3600  # 60 minutes

    def __init__(self):
        self.task_path = self.TASK_FILE
        self.proposal_path = self.PROPOSAL_DIR
        
        # Ensure proposal directory exists
        self.proposal_path.mkdir(parents=True, exist_ok=True)
        print(f"[{self.AGENT_NAME}] Initialized. Proposal storage: {self.proposal_path}")

    def read_tasks(self):
        """Reads task.md and extracts pending tasks marked with [ ]."""
        pending_tasks = []
        
        if not self.task_path.exists():
            print(f"[{self.AGENT_NAME}] WARNING: Task file not found at {self.task_path}")
            # Attempt to find it one level up if run from republic/agents
            fallback_path = Path("../brain/task.md")
            if fallback_path.exists():
                self.task_path = fallback_path
                print(f"[{self.AGENT_NAME}] Using fallback path: {self.task_path}")
            else:
                return []

        try:
            content = self.task_path.read_text(encoding='utf-8')
        except IOError as e:
            print(f"[{self.AGENT_NAME}] ERROR reading task file: {e}")
            return []

        # Regex: Find lines starting with optional whitespace/bullets, followed by [ ], capturing description (group 1)
        # Handles formats like:
        # * [ ] Task description
        # - [ ] Another task
        task_pattern = re.compile(r"^\s*[\*-]?\s*\[\s*\]\s*(.*)$", re.MULTILINE)
        
        matches = task_pattern.findall(content)
        
        for task_desc in matches:
            task_desc = task_desc.strip()
            if task_desc:
                pending_tasks.append(task_desc)
                
        return pending_tasks

    def select_task(self, pending_tasks):
        """Selects one high-priority task randomly."""
        if not pending_tasks:
            return None
        
        # Requirement: select one high-priority task randomly.
        # Since prioritization logic is external, we treat all pending tasks equally and select randomly.
        selected_task = random.choice(pending_tasks)
        print(f"[{self.AGENT_NAME}] Selected task: '{selected_task[:90]}...'")
        return selected_task

    def generate_proposal(self, task_description):
        """Generates a standardized JSON proposal."""
        
        timestamp = datetime.now().strftime("%Y%m%d%H%M%S")
        proposal_id = f"STRAT-{timestamp}-{random.randint(100, 999)}"
        
        # The 'technical_spec' directly reflects the mandate derived from the task
        technical_spec = {
            "origin_task_source": str(self.task_path),
            "origin_task_description": task_description,
            "required_action": "Define and implement solution based on the described task.",
            "derived_mandate": task_description # Placeholder for initial specification
        }
        
        title_prefix = "Strategic Initiative"
        
        # Create a title, ensuring it doesn't exceed common limits
        title_body = task_description.split('.')[0]
        title = f"{title_prefix}: {title_body[:70]}"
        if len(title_body) > 70:
            title += "..."

        proposal_data = {
            "id": proposal_id,
            "agent_source": self.AGENT_NAME,
            "date_created": datetime.now().isoformat(),
            "status": "PENDING_REVIEW",
            "priority": "HIGH",
            "title": title,
            "description": f"Formal proposal generated by {self.AGENT_NAME} to initiate work on task identified in {self.TASK_FILE}.",
            "type": "STRATEGY_INITIATION",
            "technical_spec": technical_spec,
            "votes": {
                "house": "PENDING",
                "senate": "PENDING"
            }
        }
        
        return proposal_data

    def save_proposal(self, proposal_data):
        """Saves the proposal JSON file in the governance/proposals directory."""
        proposal_id = proposal_data['proposal_id']
        filename = f"{proposal_id}.json"
        save_path = self.proposal_path / filename
        
        try:
            with open(save_path, 'w', encoding='utf-8') as f:
                json.dump(proposal_data, f, indent=4)
            print(f"[{self.AGENT_NAME}] Successfully saved proposal: {save_path.name}")
            return True
        except IOError as e:
            print(f"[{self.AGENT_NAME}] CRITICAL ERROR saving proposal {filename}: {e}")
            return False

    def run_cycle(self):
        """
        Main execution loop for the Agent Strategist. Enforces the 60-minute interval.
        """
        while True:
            start_time = time.time()
            current_time = datetime.now().strftime('%Y-%m-%d %H:%M:%S')
            print(f"\n--- [{self.AGENT_NAME}] Starting strategic cycle at {current_time} ---")

            try:
                # 1. Identify Pending Tasks
                pending_tasks = self.read_tasks()
                
                if not pending_tasks:
                    print(f"[{self.AGENT_NAME}] No pending tasks found. System seems up-to-date.")
                else:
                    print(f"[{self.AGENT_NAME}] Found {len(pending_tasks)} actionable items.")
                    
                    # 2. Select Task for action
                    selected_task = self.select_task(pending_tasks)
                    
                    if selected_task:
                        # 3. Generate Proposal
                        proposal = self.generate_proposal(selected_task)
                        
                        # 4. Save Proposal
                        self.save_proposal(proposal)

            except Exception as e:
                print(f"[{self.AGENT_NAME}] UNHANDLED EXCEPTION during cycle: {type(e).__name__}: {e}")
                
            # Calculate sleep duration
            elapsed_time = time.time() - start_time
            sleep_time = max(0, self.CYCLE_INTERVAL_SECONDS - elapsed_time)
            
            minutes_to_sleep = int(sleep_time / 60)
            
            print(f"[{self.AGENT_NAME}] Cycle finished in {elapsed_time:.2f}s.")
            print(f"[{self.AGENT_NAME}] Entering dormancy for {minutes_to_sleep} minutes.")
            
            time.sleep(sleep_time)

if __name__ == '__main__':
    # Placeholder execution setup for demonstration/testing
    # NOTE: In a real system, this agent would be managed by a central scheduler.
    
    # --- Mock File Setup for testing ---
    # Create required directory structure if it doesn't exist
    Path("brain").mkdir(exist_ok=True)
    Path("governance/proposals").mkdir(parents=True, exist_ok=True)
    
    # Create a mock task.md if it doesn't exist
    mock_task_content = """
# Project Tasks

## Phase 1: Core System
* [x] Initialize project structure.
* [ ] Implement robust error logging middleware.
* [ ] Design and document the Inter-Agent Communication Protocol (IACP).
* [x] Write initial README.

## Phase 2: Agent Development
* [ ] Create the AgentConsensus mechanism for proposal voting.
* [ ] Develop unit tests for the Fulcrum core loop.
* [x] Refactor path handling utilities.
    """
    
    task_file_path = Path("brain/task.md")
    if not task_file_path.exists():
        task_file_path.write_text(mock_task_content, encoding='utf-8')
        print(f"--- Created mock task file at {task_file_path} ---")

    # --- Run Agent ---
    try:
        strategist = AgentStrategist()
        # In a real environment, you might only run one or two cycles for testing.
        # strategist.run_cycle() 
        print(f"To run continuously, uncomment strategist.run_cycle().")
        
        # Execute one cycle immediately for setup demonstration
        print("\n--- Running a single demonstration cycle ---")
        
        # Temporary wrapper to run logic once without the sleep loop
        def run_single_cycle(agent):
            start_time = time.time()
            try:
                pending_tasks = agent.read_tasks()
                if pending_tasks:
                    selected_task = agent.select_task(pending_tasks)
                    if selected_task:
                        proposal = agent.generate_proposal(selected_task)
                        agent.save_proposal(proposal)
                else:
                    print("No pending tasks found in single run.")
            except Exception as e:
                print(f"Single run error: {e}")
            print(f"Single cycle took {time.time() - start_time:.2f}s.")
            
        run_single_cycle(strategist)

    except KeyboardInterrupt:
        print("\nStrategist stopped manually.")
    except Exception as e:
        print(f"Initialization Failed: {e}")